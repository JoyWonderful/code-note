# 排序

## 选择排序

### 简介

**选择排序**，顾名思义，就是选出所有元素中最小的元素，然后再放到前面。这个排序非常好理解，但是，时间复杂度为 $O(n^2)$ ，数据一大就要炸了。（ $n$ 为数组长度）

我们可以使用一个变量来记录其中一个最小数的下标，然后再进行第一个数与最小的数的交换。  
由于不断地将最小的数往前放，最终完成排序。但由于第 $i$ 次遍历之后，第 $i$ 个元素就是最小的元素，因此由 $i + 1$ 个元素开始判断。

### 例子

例如有这样一个数组：

$$
8 \ 5 \ 7 \ 9 \ 2 \ 6
$$

遍历后得知 $2$ 是最小的，与第一个元素 $8$ 进行交换。

$$
{\color{red}2} \ 5 \ 7 \ 9 \ {\color{red}8} \ 6
$$

以此类推：

$$
{\color{green}2} \ {\color{red}5} \ 7 \ 9 \ 8 \ 6 \\
\\ \\
{\color{green}2} \ {\color{green}5} \ {\color{red}6} \ 9 \ 8 \ {\color{red}7} \\
\\ \\
{\color{green}2} \ {\color{green}5} \ {\color{green}6} \ {\color{red}7} \ 8 \ {\color{red}9} \\
\\ \\
{\color{green}2} \ {\color{green}5} \ {\color{green}6} \ {\color{green}7} \ {\color{green}8} \ 9 \\
\\ \\
{\color{green}2} \ {\color{green}5} \ {\color{green}6} \ {\color{green}7} \ {\color{green}8} \ {\color{green}9} \\
$$

### 示例程序

```cpp
#include <cstdio>
using namespace std ;

int n, a[3002] ; 
int main()
{
    scanf("%d", &n) ;
    for(int i = 1; i <= n; i ++)
    {
        scanf("%d", &a[i]) ;
    }
    
    for(int i = 1; i <= n - 1; i ++)
    {
        int th = i ;
        for(int j = i; j <= n; j ++)
        {
            if(a[th] > a[j])
            {
                th = j ;
            }
        }
        int temp = a[i] ;
        a[i] = a[th] ;
        a[th] = temp ;
    }
    
    // printf("\n"); 
    for(int i = 1; i <= n; i ++){printf("%d ", a[i]) ;} 
    printf("\n") ;
    
    return 0 ;
}
```

### 演示网址
演示网址：[`https://visualgo.net/zh/sorting?slide=8`](https://visualgo.net/zh/sorting?slide=8)


## 冒泡排序

### 简介

**冒泡排序**，将前面一个元素和后面一个元素做对比，若前面的元素大于后面的元素即进行交换。时间复杂度也为 $O(n^2)$。

由于不断地将前一个元素大于后一个元素的一组交换，假设数组中有 $n$ 个元素，第 $i$ 次遍历后，第 $n$ 个元素就是最大的数，因此下一次遍历由 $i$ 至 $n - i$ 。

### 例子

还是上面的那个例子，利用冒泡排序：

$$
8 \ 5 \ 7 \ 9 \ 2 \ 6 \ \\ \\
\\ \\
{\color{red}5} \ {\color{red}8} \ 7 \ 9 \ 2 \ 6 \ \\
\\ \\
5 \ {\color{red}7} \ {\color{red}8} \ 9 \ 2 \ 6 \ \\
\\ \\
5 \ 7 \ {\color{red}8} \ {\color{red}9} \ 2 \ 6 \ \\
\\ \\
5 \ 7 \ 8 \ {\color{red}2} \ {\color{red}9} \ 6 \ \\
\\ \\
5 \ 7 \ 8 \ 2 \ {\color{red}6} \ {\color{red}9} \ \\
\\ \\
{\color{red}5} \ {\color{red}7} \ 8 \ 2 \ 6 \ {\color{green}9} \ \\
\\ \\
5 \ {\color{red}7} \ {\color{red}8} \ 2 \ 6 \ {\color{green}9} \ \\
\\ \\
5 \ 7 \ {\color{red}2} \ {\color{red}8} \ 6 \ {\color{green}9} \ \\
\\ \\
5 \ 7 \ 2 \ {\color{red}6} \ {\color{red}8} \ {\color{green}9} \ \\
\\ \\
{\color{red}5} \ {\color{red}7} \ 2 \ 6 \ {\color{green}8} \ {\color{green}9} \ \\
\\ \\
5 \ {\color{red}2} \ {\color{red}7} \ 6 \ {\color{green}8} \ {\color{green}9} \ \\
\\ \\
5 \ 2 \ {\color{red}6} \ {\color{red}7} \ {\color{green}8} \ {\color{green}9} \ \\
\\ \\
{\color{red}2} \ {\color{red}5} \ 6 \ {\color{green}7} \ {\color{green}8} \ {\color{green}9} \ \\
\\ \\
2 \ {\color{red}5} \ {\color{red}6} \ {\color{green}7} \ {\color{green}8} \ {\color{green}9} \ \\
\\ \\
{\color{red}2} \ {\color{red}5} \ {\color{green}6} \ {\color{green}7} \ {\color{green}8} \ {\color{green}9} \ \\
\\ \\
{\color{green}2} \ {\color{green}5} \ {\color{green}6} \ {\color{green}7} \ {\color{green}8} \ {\color{green}9} \ \\
$$

### 示例程序

```cpp
#include <cstdio>
using namespace std ;

int n, a[3002] ; 
int main()
{
    scanf("%d", &n) ;
    for(int i = 1; i <= n; i ++)
    {
        scanf("%d", &a[i]) ;
    }
    
    for(int j = 1; j <= n - 1; j ++)
    {
        for(int i = 1; i <= n - j; i ++)
        {
            if(a[i] > a[i + 1])
            {
                int t = a[i] ;
                a[i] = a[i + 1] ;
                a[i + 1] = t ;
            }
        }
    }
    
    
    // printf("\n"); 
    for(int i = 1; i <= n; i ++){printf("%d ", a[i]) ;} 
    
    return 0 ;
}
```

### 演示网址
演示网址：[`https://visualgo.net/zh/sorting?slide=7`](https://visualgo.net/zh/sorting?slide=7)


## 插入排序

### 简介

**插入排序**，是在冒泡排序的基础上做的改进。它将整个数列分为两个部分：已排序的与未排序的。

由于一个数本身就没有任何顺序，所以我们可以假设元素 $a[1]$ （假设 $1$ 为数组第一个元素）就是一个已经排列好的数列。  
随后，将 $a[2]$ 插入进已排序好的数列中。若 $a[2] > a[1]$ 则不交换，否则则交换。这就是一个循环的过程。插入进已排列好的数列中时，这个比较就是冒泡排序的过程：
> 将前面一个元素和后面一个元素做对比，若前面的元素大于后面的元素即进行交换。

### 例子

依然是前面那个样例，在这里，我们假设有一个空间是已排序空序列，另一个是未排序序列。

$$
\boxed{
\begin{aligned}
&说明：\\
&? \ 代表未排序序列 \\
&! \ 代表已排序序列 \\
\end{aligned}
}
$$

$$
\begin{aligned}
? \ &8 \ 5 \ 7 \ 9 \ 2 \ 6 \ \\
! \ &[Empty] \\ \\

? \ &5 \ 7 \ 9 \ 2 \ 6 \ \\
! \ &{\color{yellow}8} \\ \\

? \ &7 \ 9 \ 2 \ 6 \ \\
! \ &{\color{yellow}8} \ {\color{yellow}5} \\ \\

? \ &7 \ 9 \ 2 \ 6 \ \\
! \ &{\color{yellow}5} \ {\color{yellow}8} \\ \\

? \ &9 \ 2 \ 6 \ \\
! \ &{\color{yellow}5} \ {\color{yellow}8} \ {\color{yellow}7} \\ \\

? \ &9 \ 2 \ 6 \ \\
! \ &{\color{yellow}5} \ {\color{yellow}7} \ {\color{yellow}8} \\ \\

&...(不再详细演示)
\end{aligned}
$$

### 示例程序

```cpp
#include <cstdio>
using namespace std ;

int a[100010] ;
int main()
{
    int n ;
    scanf("%d", &n) ;
    for(int i = 1; i <= n; i ++)
    {
        scanf("%d", &a[i]) ;
    }
    
    for(int j = 1; j <= n - 1; j ++)
    {
        for(int i = j; i >= 1; i --)
        {
            if(a[i + 1] < a[i])
            {
                int t = a[i] ;
                a[i] = a[i + 1] ;
                a[i + 1] = t ;
            }
            else
            {
                break ;
            }
        }
    }
    
    for(int i = 1; i <= n; i ++)
    {
        printf("%d ", a[i]) ;
    }
    printf("\n") ;
    
    return 0 ;
}
```

可以看到，它比普通冒泡排序快在当前一个元素大于等于后一个元素时会退出循环。但最坏的情况还是 $O(n^2)$ （也是平均情况），因为如果他时一个倒序序列的话，这样排序每次都要从头到尾比较一遍，这和冒泡排序是一样的。

### 演示网址
演示网址：[`https://visualgo.net/zh/sorting?slide=9`](https://visualgo.net/zh/sorting?slide=9)


# THE END
